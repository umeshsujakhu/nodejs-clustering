Reference : https://blog.bitsrc.io/nodejs-performance-optimization-with-clustering-b52915054cc2


Load Testing : 
    - loadtest http://localhost:3000/api/nocluster -n 1000 -c 100

    - loadtest http://localhost:3001/api/cluster -n 1000 -c 100


Awesome! Youâ€™re already in a great position with working code examples and load test results. Hereâ€™s how you can structure your knowledge-sharing session to explain Node.js clustering effectively with performance benchmarking.

â¸»

ðŸ§  Node.js Clustering - Knowledge Sharing

1. Why Clustering in Node.js?
	â€¢	Node.js runs in a single-threaded event loop by default.
	â€¢	While itâ€™s great for I/O-bound operations, it cannot utilize multiple CPU cores for CPU-bound operations.
	â€¢	Clustering is a way to fork multiple instances (workers) of your Node.js app to utilize all CPU cores.

â€œEach worker is a separate Node.js process with its own event loop and memory.â€

â¸»

2. Code Explanation

ðŸ§± no-clustering.js
	â€¢	A simple Express app.
	â€¢	Runs in a single process.
	â€¢	CPU-intensive endpoint: /api/nocluster simulates a heavy calculation.

for (let i = Math.pow(base, 7); i >= 0; i--) {
  result += i + Math.pow(i, 10);
}

	â€¢	Only one request is processed at a time during heavy computation â€” others wait.

â¸»

ðŸ§  clustering.js
	â€¢	Uses Nodeâ€™s cluster module.
	â€¢	Checks if itâ€™s the master process:
	â€¢	Logs CPU count.
	â€¢	Spawns workers equal to CPU cores.
	â€¢	Replaces any worker if it crashes.

for (let i = 0; i < totalCPUs; i++) {
  cluster.fork();
}

	â€¢	Each worker runs its own instance of the Express app.
	â€¢	Incoming requests get distributed across all workers.
	â€¢	Effectively parallel processing of CPU-bound tasks.

â¸»

3. Visual Comparison

Feature	No Clustering	With Clustering
Processes	Single	Multiple (per core)
CPU Core Usage	1	All available cores
Handles CPU-heavy ops	Sequentially	In parallel
Performance under load	Poor	Better
Fault tolerance	No	Yes (respawns worker)



â¸»

4. Load Testing Explained

âœ… What you did:

You used loadtest to simulate 1000 requests with 100 concurrent connections to test each app.

loadtest http://localhost:3000/api/nocluster -n 1000 -c 100
loadtest http://localhost:3001/api/cluster -n 1000 -c 100

ðŸ“Š Interpreting the results:
	â€¢	Without Clustering:
	â€¢	You likely saw longer response times.
	â€¢	Node.js is blocked during the CPU-heavy task.
	â€¢	Other requests have to wait in line.
	â€¢	With Clustering:
	â€¢	The load is spread across multiple processes.
	â€¢	Multiple requests can be handled simultaneously.
	â€¢	Resulted in lower average latency and better throughput.

You can also show the stats output from loadtest like:

Requests: 1000
Concurrency: 100
Completed requests: 1000
Total time: 12s
Requests per second: 83.3

Compare those for both scenarios.

â¸»

5. Real-world Use Cases
	â€¢	Ideal for CPU-intensive tasks like image processing, data crunching, or encryption.
	â€¢	Helps prevent blocking the event loop.
	â€¢	Use along with PM2 or Node.js Cluster for production setups.

â¸»

6. Caveats
	â€¢	Workers donâ€™t share memory â€” no shared state.
	â€¢	Youâ€™ll need IPC (inter-process communication) or shared databases like Redis for shared data.
	â€¢	Still runs multiple processes â€” not threads â€” unlike multithreading in other languages.

â¸»

7. Tips for Presentation
	â€¢	Start with the problem: single-threaded limitation of Node.js.
	â€¢	Walk through both versions of the code briefly.
	â€¢	Emphasize the performance difference (share your test results).
	â€¢	Use diagrams if possible (master-worker structure).
	â€¢	End with real-world usage and gotchas.

â¸»

Would you like help designing a slide deck or preparing a sample result chart from your load test results?